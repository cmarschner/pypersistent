======================================================================
PERSISTENT MAP vs PYTHON DICT - PERFORMANCE COMPARISON
======================================================================

======================================================================
TESTING WITH 100 ELEMENTS
======================================================================

=== Insertion Test (n=100) ===
dict:          15.04 µs
PersistentMap: 107.13 µs
Ratio:         7.12x slower

=== Lookup Test (n=100) ===
dict:          15.00 µs
PersistentMap: 31.17 µs
Ratio:         2.08x slower

=== Contains Test (n=100) ===
dict:          12.79 µs
PersistentMap: 28.42 µs
Ratio:         2.22x slower

=== Update Test (n=100) ===
dict:          3.42 µs
PersistentMap: 9.87 µs
Ratio:         2.89x slower

=== Deletion Test (n=100) ===
dict:          2.46 µs
PersistentMap: 10.33 µs
Ratio:         4.20x slower

=== Iteration Test (n=100) ===
dict:          4.71 µs
PersistentMap: 134.25 µs
Ratio:         28.52x slower

=== Create from Dict Test (n=100) ===
dict.copy():            875.44 ns
PersistentMap.from_dict: 40.63 µs
Ratio:                   46.41x slower

=== Merge Test (n=100) ===
Merging two maps of 50 elements each...
dict (copy + update): 3.00 µs
PersistentMap.merge:  25.33 µs
Ratio:                8.44x slower
PersistentMap (| op): 19.92 µs

=== Structural Sharing Test (n=100) ===
Creating 100 variants with one modification each...
dict (copy):   104.25 µs
PersistentMap: 75.58 µs
Ratio:         1.38x faster (PersistentMap wins!)

======================================================================
TESTING WITH 1,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000) ===
dict:          133.58 µs
PersistentMap: 931.71 µs
Ratio:         6.97x slower

=== Lookup Test (n=1,000) ===
dict:          138.88 µs
PersistentMap: 326.00 µs
Ratio:         2.35x slower

=== Contains Test (n=1,000) ===
dict:          129.17 µs
PersistentMap: 306.71 µs
Ratio:         2.37x slower

=== Update Test (n=1,000) ===
dict:          17.46 µs
PersistentMap: 112.12 µs
Ratio:         6.42x slower

=== Deletion Test (n=1,000) ===
dict:          15.67 µs
PersistentMap: 114.21 µs
Ratio:         7.29x slower

=== Iteration Test (n=1,000) ===
dict:          32.50 µs
PersistentMap: 253.04 µs
Ratio:         7.79x slower

=== Create from Dict Test (n=1,000) ===
dict.copy():            2.46 µs
PersistentMap.from_dict: 455.17 µs
Ratio:                   185.13x slower

=== Merge Test (n=1,000) ===
Merging two maps of 500 elements each...
dict (copy + update): 17.38 µs
PersistentMap.merge:  267.88 µs
Ratio:                15.42x slower
PersistentMap (| op): 257.79 µs

=== Structural Sharing Test (n=1,000) ===
Creating 100 variants with one modification each...
dict (copy):   471.83 µs
PersistentMap: 96.75 µs
Ratio:         4.88x faster (PersistentMap wins!)

======================================================================
TESTING WITH 1,000,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000,000) ===
dict:          304.33 ms
PersistentMap: 3.20 s
Ratio:         10.50x slower

=== Lookup Test (n=1,000,000) ===
dict:          417.93 ms
PersistentMap: 1.04 s
Ratio:         2.48x slower

=== Contains Test (n=1,000,000) ===
dict:          442.52 ms
PersistentMap: 969.83 ms
Ratio:         2.19x slower

=== Update Test (n=1,000,000) ===
dict:          93.67 ms
PersistentMap: 416.63 ms
Ratio:         4.45x slower

=== Deletion Test (n=1,000,000) ===
dict:          73.27 ms
PersistentMap: 526.47 ms
Ratio:         7.19x slower

=== Iteration Test (n=1,000,000) ===
dict:          36.79 ms
PersistentMap: 633.65 ms
Ratio:         17.22x slower

=== Create from Dict Test (n=1,000,000) ===
dict.copy():            16.11 ms
PersistentMap.from_dict: 2.63 s
Ratio:                   163.24x slower

=== Merge Test (n=1,000,000) ===
Merging two maps of 500,000 elements each...
dict (copy + update): 107.14 ms
PersistentMap.merge:  967.97 ms
Ratio:                9.03x slower
PersistentMap (| op): 995.65 ms

=== Structural Sharing Test (n=1,000,000) ===
Creating 100 variants with one modification each...
dict (copy):   1.49 s
PersistentMap: 660.58 µs
Ratio:         2254.01x faster (PersistentMap wins!)

=== Memory Footprint Test (n=1,000,000) ===
dict (approximate):          30,758,320 bytes
PersistentMap (approximate): 56 bytes
Note: This is a rough estimate and doesn't include all internal structures

======================================================================
SUMMARY
======================================================================

PersistentMap Trade-offs:

ADVANTAGES:
  - Immutability: Thread-safe, no defensive copying needed
  - Structural Sharing: Creating variants is O(log n), not O(n)
  - Time-travel: Keep old versions without full copies
  - Functional Programming: Natural fit for FP paradigms

DISADVANTAGES:
  - Slower raw performance for individual operations
  - Higher constant factors due to tree structure
  - More memory per entry (node overhead)

USE CASES:
  - When you need multiple versions of data
  - Undo/redo functionality
  - Concurrent access without locks
  - Functional/immutable architecture
  - When copying cost matters more than lookup speed

