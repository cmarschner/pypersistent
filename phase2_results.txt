======================================================================
PERSISTENT MAP vs PYTHON DICT - PERFORMANCE COMPARISON
======================================================================

======================================================================
TESTING WITH 100 ELEMENTS
======================================================================

=== Insertion Test (n=100) ===
dict:          15.88 µs
PersistentMap: 99.00 µs
Ratio:         6.24x slower

=== Lookup Test (n=100) ===
dict:          15.58 µs
PersistentMap: 30.38 µs
Ratio:         1.95x slower

=== Contains Test (n=100) ===
dict:          12.75 µs
PersistentMap: 28.29 µs
Ratio:         2.22x slower

=== Update Test (n=100) ===
dict:          3.38 µs
PersistentMap: 10.33 µs
Ratio:         3.06x slower

=== Deletion Test (n=100) ===
dict:          2.17 µs
PersistentMap: 10.54 µs
Ratio:         4.86x slower

=== Iteration Test (n=100) ===
dict:          4.46 µs
PersistentMap: 121.96 µs
Ratio:         27.35x slower

=== Create from Dict Test (n=100) ===
dict.copy():            875.44 ns
PersistentMap.from_dict: 42.46 µs
Ratio:                   48.50x slower

=== Merge Test (n=100) ===
Merging two maps of 50 elements each...
dict (copy + update): 3.04 µs
PersistentMap.merge:  23.08 µs
Ratio:                7.59x slower
PersistentMap (| op): 17.92 µs

=== Structural Sharing Test (n=100) ===
Creating 100 variants with one modification each...
dict (copy):   78.00 µs
PersistentMap: 74.50 µs
Ratio:         1.05x faster (PersistentMap wins!)

======================================================================
TESTING WITH 1,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000) ===
dict:          129.13 µs
PersistentMap: 919.63 µs
Ratio:         7.12x slower

=== Lookup Test (n=1,000) ===
dict:          142.08 µs
PersistentMap: 327.71 µs
Ratio:         2.31x slower

=== Contains Test (n=1,000) ===
dict:          132.00 µs
PersistentMap: 310.25 µs
Ratio:         2.35x slower

=== Update Test (n=1,000) ===
dict:          16.87 µs
PersistentMap: 114.92 µs
Ratio:         6.81x slower

=== Deletion Test (n=1,000) ===
dict:          15.75 µs
PersistentMap: 114.67 µs
Ratio:         7.28x slower

=== Iteration Test (n=1,000) ===
dict:          33.83 µs
PersistentMap: 253.38 µs
Ratio:         7.49x slower

=== Create from Dict Test (n=1,000) ===
dict.copy():            3.00 µs
PersistentMap.from_dict: 459.25 µs
Ratio:                   153.09x slower

=== Merge Test (n=1,000) ===
Merging two maps of 500 elements each...
dict (copy + update): 18.83 µs
PersistentMap.merge:  288.71 µs
Ratio:                15.33x slower
PersistentMap (| op): 260.12 µs

=== Structural Sharing Test (n=1,000) ===
Creating 100 variants with one modification each...
dict (copy):   462.04 µs
PersistentMap: 108.67 µs
Ratio:         4.25x faster (PersistentMap wins!)

======================================================================
TESTING WITH 1,000,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000,000) ===
dict:          329.03 ms
PersistentMap: 3.08 s
Ratio:         9.36x slower

=== Lookup Test (n=1,000,000) ===
dict:          449.36 ms
PersistentMap: 1.01 s
Ratio:         2.25x slower

=== Contains Test (n=1,000,000) ===
dict:          365.33 ms
PersistentMap: 866.90 ms
Ratio:         2.37x slower

=== Update Test (n=1,000,000) ===
dict:          76.66 ms
PersistentMap: 393.65 ms
Ratio:         5.14x slower

=== Deletion Test (n=1,000,000) ===
dict:          64.27 ms
PersistentMap: 451.49 ms
Ratio:         7.02x slower

=== Iteration Test (n=1,000,000) ===
dict:          33.70 ms
PersistentMap: 635.11 ms
Ratio:         18.85x slower

=== Create from Dict Test (n=1,000,000) ===
dict.copy():            11.58 ms
PersistentMap.from_dict: 2.39 s
Ratio:                   206.21x slower

=== Merge Test (n=1,000,000) ===
Merging two maps of 500,000 elements each...
dict (copy + update): 118.36 ms
PersistentMap.merge:  977.81 ms
Ratio:                8.26x slower
PersistentMap (| op): 983.13 ms

=== Structural Sharing Test (n=1,000,000) ===
Creating 100 variants with one modification each...
dict (copy):   1.55 s
PersistentMap: 10.86 ms
Ratio:         142.27x faster (PersistentMap wins!)

=== Memory Footprint Test (n=1,000,000) ===
dict (approximate):          30,758,320 bytes
PersistentMap (approximate): 56 bytes
Note: This is a rough estimate and doesn't include all internal structures

======================================================================
SUMMARY
======================================================================

PersistentMap Trade-offs:

ADVANTAGES:
  - Immutability: Thread-safe, no defensive copying needed
  - Structural Sharing: Creating variants is O(log n), not O(n)
  - Time-travel: Keep old versions without full copies
  - Functional Programming: Natural fit for FP paradigms

DISADVANTAGES:
  - Slower raw performance for individual operations
  - Higher constant factors due to tree structure
  - More memory per entry (node overhead)

USE CASES:
  - When you need multiple versions of data
  - Undo/redo functionality
  - Concurrent access without locks
  - Functional/immutable architecture
  - When copying cost matters more than lookup speed

