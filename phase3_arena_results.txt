======================================================================
PERSISTENT MAP vs PYTHON DICT - PERFORMANCE COMPARISON
======================================================================

======================================================================
TESTING WITH 100 ELEMENTS
======================================================================

=== Insertion Test (n=100) ===
dict:          11.96 µs (±5.6%)
PersistentMap: 83.25 µs
Ratio:         6.96x slower

=== Lookup Test (n=100) ===
dict:          12.71 µs
PersistentMap: 28.37 µs
Ratio:         2.23x slower

=== Contains Test (n=100) ===
dict:          12.08 µs
PersistentMap: 26.25 µs
Ratio:         2.17x slower

=== Update Test (n=100) ===
dict:          1.75 µs
PersistentMap: 8.08 µs
Ratio:         4.62x slower

=== Deletion Test (n=100) ===
dict:          1.58 µs
PersistentMap: 8.12 µs
Ratio:         5.13x slower

=== Iteration Test (n=100) ===
dict:          3.29 µs
PersistentMap: 46.12 µs
Ratio:         14.02x slower

=== Create from Dict Test (n=100) ===
dict.copy():             416.30 ns (±46.7%)
PersistentMap.from_dict: 32.50 µs (±8.0%)
Ratio:                   78.07x slower
  Statistics:
    dict:  median=416.30 ns, CV=46.7%, range=374.39 ns-1.04 µs
    pmap:  median=32.50 µs, CV=8.0%, range=30.96 µs-36.71 µs

=== Merge Test (n=100) ===
Merging two maps of 50 elements each...
dict (copy + update): 1.38 µs
PersistentMap.merge:  20.58 µs
Ratio:                14.96x slower
PersistentMap (| op): 18.62 µs

=== Structural Sharing Test (n=100) ===
Creating 100 variants with one modification each...
dict (copy):   66.83 µs (±19.4%)
PersistentMap: 89.33 µs (±7.6%)
Ratio:         0.75x faster (PersistentMap wins!)
  Statistics:
    dict:  median=66.83 µs, CV=19.4%, range=65.17 µs-103.54 µs
    pmap:  median=89.33 µs, CV=7.6%, range=88.29 µs-107.88 µs

======================================================================
TESTING WITH 1,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000) ===
dict:          128.58 µs
PersistentMap: 900.92 µs
Ratio:         7.01x slower

=== Lookup Test (n=1,000) ===
dict:          141.92 µs
PersistentMap: 320.29 µs
Ratio:         2.26x slower

=== Contains Test (n=1,000) ===
dict:          135.33 µs
PersistentMap: 307.62 µs
Ratio:         2.27x slower

=== Update Test (n=1,000) ===
dict:          16.92 µs
PersistentMap: 110.29 µs
Ratio:         6.52x slower

=== Deletion Test (n=1,000) ===
dict:          15.42 µs
PersistentMap: 111.33 µs
Ratio:         7.22x slower

=== Iteration Test (n=1,000) ===
dict:          32.71 µs
PersistentMap: 247.83 µs
Ratio:         7.58x slower

=== Create from Dict Test (n=1,000) ===
dict.copy():             3.17 µs
PersistentMap.from_dict: 454.00 µs
Ratio:                   143.38x slower
  Statistics:
    dict:  median=3.17 µs, CV=3.7%, range=3.04 µs-3.38 µs
    pmap:  median=454.00 µs, CV=2.1%, range=440.13 µs-465.71 µs

=== Merge Test (n=1,000) ===
Merging two maps of 500 elements each...
dict (copy + update): 14.00 µs
PersistentMap.merge:  268.83 µs
Ratio:                19.20x slower
PersistentMap (| op): 260.29 µs

=== Structural Sharing Test (n=1,000) ===
Creating 100 variants with one modification each...
dict (copy):   480.13 µs (±17.5%)
PersistentMap: 125.58 µs (±9.2%)
Ratio:         3.82x faster (PersistentMap wins!)
  Statistics:
    dict:  median=480.13 µs, CV=17.5%, range=457.83 µs-687.17 µs
    pmap:  median=125.58 µs, CV=9.2%, range=120.96 µs-155.33 µs

======================================================================
TESTING WITH 1,000,000 ELEMENTS
======================================================================

=== Insertion Test (n=1,000,000) ===
dict:          397.14 ms
PersistentMap: 3.11 s
Ratio:         7.83x slower

=== Lookup Test (n=1,000,000) ===
dict:          413.92 ms
PersistentMap: 982.57 ms
Ratio:         2.37x slower

=== Contains Test (n=1,000,000) ===
dict:          394.19 ms
PersistentMap: 968.86 ms
Ratio:         2.46x slower

=== Update Test (n=1,000,000) ===
dict:          84.87 ms
PersistentMap: 449.76 ms
Ratio:         5.30x slower

=== Deletion Test (n=1,000,000) ===
dict:          83.53 ms
PersistentMap: 552.51 ms
Ratio:         6.61x slower

=== Iteration Test (n=1,000,000) ===
dict:          35.65 ms
PersistentMap: 690.49 ms
Ratio:         19.37x slower

=== Create from Dict Test (n=1,000,000) ===
dict.copy():             13.36 ms (±26.8%)
PersistentMap.from_dict: 2.74 s
Ratio:                   205.37x slower
  Statistics:
    dict:  median=13.36 ms, CV=26.8%, range=12.28 ms-23.39 ms
    pmap:  median=2.74 s, CV=1.3%, range=2.71 s-2.81 s

=== Merge Test (n=1,000,000) ===
Merging two maps of 500,000 elements each...
dict (copy + update): 108.54 ms
PersistentMap.merge:  1.03 s
Ratio:                9.44x slower
PersistentMap (| op): 1.02 s

=== Structural Sharing Test (n=1,000,000) ===
Creating 100 variants with one modification each...
dict (copy):   2.27 s
PersistentMap: 218.96 µs (±48.1%)
Ratio:         10362.75x faster (PersistentMap wins!)
  Statistics:
    dict:  median=2.27 s, CV=4.6%, range=2.05 s-2.35 s
    pmap:  median=218.96 µs, CV=48.1%, range=203.50 µs-569.79 µs

=== Memory Footprint Test (n=1,000,000) ===
dict (approximate):          30,758,320 bytes
PersistentMap (approximate): 56 bytes
Note: This is a rough estimate and doesn't include all internal structures

======================================================================
SUMMARY
======================================================================

PersistentMap Trade-offs:

ADVANTAGES:
  - Immutability: Thread-safe, no defensive copying needed
  - Structural Sharing: Creating variants is O(log n), not O(n)
  - Time-travel: Keep old versions without full copies
  - Functional Programming: Natural fit for FP paradigms

DISADVANTAGES:
  - Slower raw performance for individual operations
  - Higher constant factors due to tree structure
  - More memory per entry (node overhead)

USE CASES:
  - When you need multiple versions of data
  - Undo/redo functionality
  - Concurrent access without locks
  - Functional/immutable architecture
  - When copying cost matters more than lookup speed

