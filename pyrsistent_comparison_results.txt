
======================================================================
PYPERSISTENT vs PYRSISTENT - PERFORMANCE COMPARISON
======================================================================

pypersistent: Our C++-based implementation (with Phase 1-4 optimizations)
pyrsistent:   Pure Python implementation (v0.20.0, no C extensions)


======================================================================
TESTING WITH 100 ELEMENTS
======================================================================

=== Bulk Construction from Dict (n=100) ===
pypersistent (C++):  34.25 µs (±21.5%)
pyrsistent (Python): 20.04 µs (±28.4%)
Speedup:             1.71x slower (pyrsistent wins)
  pypersistent range: 28.54 µs-51.29 µs
  pyrsistent range:   19.42 µs-37.04 µs

=== Lookup Test (n=100, 100 lookups) ===
pypersistent (C++):  18.33 µs (±6.4%)
pyrsistent (Python): 59.00 µs (±7.0%)
Speedup:             3.22x faster

=== Assoc/Update Test (n=100, 100 updates) ===
pypersistent (C++):  68.92 µs (±3.6%)
pyrsistent (Python): 355.83 µs (±4.3%)
Speedup:             5.16x faster

=== Iteration Test (n=100) ===
pypersistent (C++):  44.75 µs (±75.1%)
pyrsistent (Python): 11.54 µs (±23.4%)
Speedup:             3.88x slower

=== Merge Test (n=100, merging 50 + 50) ===
pypersistent (C++):  17.67 µs (±10.0%)
pyrsistent (Python): 119.21 µs (±4.7%)
Speedup:             6.75x faster

=== Structural Sharing Test (n=100, 100 variants) ===
pypersistent (C++):  74.63 µs (±10.9%)
pyrsistent (Python): 361.12 µs (±2.4%)
Speedup:             4.84x faster


======================================================================
TESTING WITH 1,000 ELEMENTS
======================================================================

=== Bulk Construction from Dict (n=1,000) ===
pypersistent (C++):  74.58 µs (±18.5%)
pyrsistent (Python): 192.54 µs (±15.9%)
Speedup:             2.58x faster (pypersistent wins!)
  pypersistent range: 71.79 µs-114.96 µs
  pyrsistent range:   188.75 µs-278.29 µs

=== Lookup Test (n=1,000, 1000 lookups) ===
pypersistent (C++):  187.54 µs (±1.3%)
pyrsistent (Python): 665.38 µs (±0.7%)
Speedup:             3.55x faster

=== Assoc/Update Test (n=1,000, 100 updates) ===
pypersistent (C++):  84.67 µs (±3.1%)
pyrsistent (Python): 398.46 µs (±2.1%)
Speedup:             4.71x faster

=== Iteration Test (n=1,000) ===
pypersistent (C++):  215.50 µs (±2.0%)
pyrsistent (Python): 109.25 µs (±2.2%)
Speedup:             1.97x slower

=== Merge Test (n=1,000, merging 500 + 500) ===
pypersistent (C++):  9.17 µs (±16.3%)
pyrsistent (Python): 1.19 ms (±4.1%)
Speedup:             129.98x faster

=== Structural Sharing Test (n=1,000, 100 variants) ===
pypersistent (C++):  91.75 µs (±10.5%)
pyrsistent (Python): 396.75 µs (±2.7%)
Speedup:             4.32x faster


======================================================================
TESTING WITH 10,000 ELEMENTS
======================================================================

=== Bulk Construction from Dict (n=10,000) ===
pypersistent (C++):  1.16 ms (±2.4%)
pyrsistent (Python): 2.77 ms (±17.2%)
Speedup:             2.38x faster (pypersistent wins!)
  pypersistent range: 1.14 ms-1.22 ms
  pyrsistent range:   2.62 ms-4.05 ms

=== Lookup Test (n=10,000, 1000 lookups) ===
pypersistent (C++):  227.46 µs (±6.9%)
pyrsistent (Python): 673.58 µs (±2.4%)
Speedup:             2.96x faster

=== Assoc/Update Test (n=10,000, 100 updates) ===
pypersistent (C++):  98.25 µs (±2.7%)
pyrsistent (Python): 409.83 µs (±3.2%)
Speedup:             4.17x faster

=== Iteration Test (n=10,000) ===
pypersistent (C++):  1.85 ms (±0.6%)
pyrsistent (Python): 1.05 ms (±2.5%)
Speedup:             1.76x slower

=== Merge Test (n=10,000, merging 5,000 + 5,000) ===
pypersistent (C++):  158.79 µs (±4.3%)
pyrsistent (Python): 12.88 ms (±5.2%)
Speedup:             81.09x faster

=== Structural Sharing Test (n=10,000, 100 variants) ===
pypersistent (C++):  107.79 µs (±11.0%)
pyrsistent (Python): 399.25 µs (±2.2%)
Speedup:             3.70x faster


======================================================================
TESTING WITH 100,000 ELEMENTS
======================================================================

=== Bulk Construction from Dict (n=100,000) ===
pypersistent (C++):  19.98 ms (±2.1%)
pyrsistent (Python): 36.63 ms (±6.4%)
Speedup:             1.83x faster (pypersistent wins!)
  pypersistent range: 19.50 ms-20.65 ms
  pyrsistent range:   33.62 ms-41.22 ms

=== Lookup Test (n=100,000, 1000 lookups) ===
pypersistent (C++):  258.75 µs (±93.5%)
pyrsistent (Python): 741.79 µs (±27.7%)
Speedup:             2.87x faster

=== Assoc/Update Test (n=100,000, 100 updates) ===
pypersistent (C++):  114.58 µs (±55.4%)
pyrsistent (Python): 447.00 µs (±14.1%)
Speedup:             3.90x faster

=== Iteration Test (n=100,000) ===
pypersistent (C++):  18.99 ms (±3.3%)
pyrsistent (Python): 10.79 ms (±3.1%)
Speedup:             1.76x slower

=== Merge Test (n=100,000, merging 50,000 + 50,000) ===
pypersistent (C++):  543.29 µs (±44.4%)
pyrsistent (Python): 141.02 ms (±3.0%)
Speedup:             259.57x faster

=== Structural Sharing Test (n=100,000, 100 variants) ===
pypersistent (C++):  135.71 µs (±31.7%)
pyrsistent (Python): 434.46 µs (±3.4%)
Speedup:             3.20x faster


======================================================================
SUMMARY
======================================================================

pypersistent leverages C++ for:
  - Efficient HAMT node operations
  - Optimized hash calculations
  - Fast memory management (intrusive refcounting)
  - Arena allocator for bulk operations (Phase 3)

pyrsistent (pure Python) is:
  - Portable and easy to install
  - Well-tested and mature
  - But slower due to Python overhead

Use pypersistent when:
  - Performance is critical
  - Working with large datasets
  - Building performance-sensitive applications

Use pyrsistent when:
  - Pure Python is required
  - Compatibility across platforms is paramount
  - Performance is not the primary concern
